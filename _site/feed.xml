<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="pt-BR"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="pt-BR" /><updated>2025-09-07T17:15:42-03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">CODIGUIN</title><subtitle>Esse é um blog pessoal, onde serão postados conteúdos diversos relacionados aos meus estudos no CIn - UFPE,  enquanto graduando no Bacharel em IA.</subtitle><entry><title type="html">Do Zero ao Um: Aprendendo Modelos de Agente</title><link href="http://localhost:4000/programa%C3%A7%C3%A3o/2025/07/08/post.html" rel="alternate" type="text/html" title="Do Zero ao Um: Aprendendo Modelos de Agente" /><published>2025-07-08T00:00:00-03:00</published><updated>2025-07-08T00:00:00-03:00</updated><id>http://localhost:4000/programa%C3%A7%C3%A3o/2025/07/08/post</id><content type="html" xml:base="http://localhost:4000/programa%C3%A7%C3%A3o/2025/07/08/post.html"><![CDATA[<p>Agentes de IA. IA Agêntica. Arquitetura Agêntica. <em>Workflow</em> Agênticos. Modelos Agênticos. Agentes estão em todos os lugares. Mas o que exatamente são eles, e como construir sistemas agênticos robustos e eficazes? Enquanto o termo “agente” é amplamente usado, uma característica fundamental é a sua capacidade de planejar e executar tarefas dinamicamente, frequentemente utilizando <strong>ferramentas externas</strong> e <strong>memória</strong> para alcançar objetivos complexos.</p>

<p>Este post tem como objetivo explorar modelos de design comuns. Visualizar essas estruturas como padrões reutilizáveis para construir aplicações de IA. Compreendê-los oferece um modelo mental para solucionar problemas complexos e projetar sistemas que sejam escaláveis, modulares e adaptáveis.</p>

<p>Vamos aprofundar em diversos padrões comuns diferenciando entre <em>workflows</em> mais estruturados e padrões agênticos mais dinâmicos. <em>Workflows</em> geralmente seguem caminhos predefinidos, enquanto agentes possuem mais autonomia para decidir seu curso de ação.</p>

<h3 id="por-que-padrões-agênticos-importam">Por que “Padrões Agênticos” importam?</h3>

<ul>
  <li>
    <p>Padrões oferecem uma maneira estruturada de pensar e projetar sistemas.</p>
  </li>
  <li>
    <p>Padrões nos permitem construir e expandir aplicações de IA em complexidade e adaptar a requisitos variáveis. Designs modulares baseados em padrões são mais fáceis de modificar e estender.</p>
  </li>
  <li>
    <p>Padrões ajudam a gerenciar a complexidade da coordenação de múltiplos agentes, ferramentas e fluxos de trabalho, oferecendo modelos reutilizáveis e confiáveis. Eles promovem as melhores práticas e o entendimento compartilhado entre os desenvolvedores.</p>
  </li>
</ul>

<h3 id="quando-e-quando-não-usar-agentes">Quando (e quando não) usar Agentes?</h3>

<p>Antes de mergulharmos nos padrões, é crucial considerar quando uma abordagem agêntica é realmente necessária.</p>

<ul>
  <li>
    <p>Sempre busque a solução mais simples primeiro. Se você souber os passos exatos necessários para resolver um problema, um fluxo de trabalho fixo ou até mesmo um script simples pode ser mais eficiente e acertivo do que um agente.</p>
  </li>
  <li>
    <p>Sistemas agênticos frequentemente trocam o aumento da latência e do custo computacional por um desempenho potencialmente melhor em tarefas complexas, ambíguas ou dinâmicas. Certifique-se de que os benefícios superam esses custos.</p>
  </li>
  <li>
    <p>Use <em>workflows</em> para previsibilidade e consistência ao lidar com tarefas bem definidas onde os passos são conhecidos.</p>
  </li>
  <li>
    <p>Use agentes quando flexibilidade, adaptabilidade e tomadas de decisões orientadas por modelos são necessárias.</p>
  </li>
  <li>
    <p>Mantenha a Simplicidade (ainda que com agentes): Mesmo ao construir sistemas agênticos, esforce-se pelo design mais simples e eficaz. Agentes excessivamente complexos podem se tornar difíceis de depurar e gerenciar.</p>
  </li>
  <li>
    <p>Agentes introduzem imprevisibilidade inerente e potenciais erros. Sistemas agênticos devem incorporar registro de erros robusto, tratamento de exceções e mecanismos de repetição, dando ao sistema (ou ao LLM subjacente) a chance de se autocorrigir.</p>
  </li>
</ul>

<p>Abaixo, exploraremos 3 padrões de <em>workflows</em> comuns e 4 padrões agênticos. Ilustraremos cada um usando chamadas de API puras, sem depender de frameworks específicos como LangChain, LangGraph, LlamaIndex ou CrewAI, para focar nos conceitos centrais.</p>

<h3 id="visão-geral-dos-padrões">Visão Geral dos Padrões</h3>

<p>Vamos cobrir os seguintes modelos:</p>

<ul>
  <li><a href="#workflow-prompt-encadeado"><em>Workflow</em>: Prompt encadeado</a></li>
  <li><a href="#workflow-roteamento-ou-handoff"><em>Workflow</em>: Roteamento ou <em>Handoff</em></a></li>
  <li><a href="#workflow-paralelização"><em>Workflow</em>: Paralelização</a></li>
  <li><a href="#padrão-de-reflexão">Padrão de Reflexão</a></li>
  <li><a href="#padrão-de-uso-de-ferramentas">Padrão de Uso de Ferramentas</a></li>
  <li><a href="#padrão-planejamento-orquestrador-trabalhadores">Padrão: Planejamento (Orquestrador-Trabalhadores)</a></li>
  <li><a href="#padrão-multiagente">Padrão: Multiagente</a></li>
</ul>

<h3 id="workflow-prompt-encadeado"><em>Workflow</em>: Prompt encadeado</h3>

<p><img src="/assets/img/post_07_08/prompt-chaining.png" alt="prompt-encadeado" /></p>

<p>A saída de uma chamada de <em>LLM</em> alimenta sequencialmente a entrada da próxima chamada de <em>LLM</em>. Esse padrão decompõe uma tarefa em uma sequência fixa de passos. Cada passo é tratado por uma chamada de <em>LLM</em> que processa a saída da anterior. É adequado para tarefas que podem ser divididas de forma clara em subtarefas previsíveis e sequenciais.</p>

<h4 id="casos-de-uso">Casos de Uso</h4>

<ul>
  <li>
    <p><strong>Gerar um documento estruturado</strong>: <em>LLM 1</em> cria um esboço, <em>LLM 2</em> valida o esboço contra critérios, <em>LLM 3</em> escreve o conteúdo com base no esboço validado.</p>
  </li>
  <li>
    <p><strong>Processamento de dados em várias etapas</strong>: Extrair informações, transformá-las e depois resumi-las.</p>
  </li>
  <li>
    <p><strong>Gerar conjunto de notícias com base em entradas curadas</strong>.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="n">os</span>
<span class="kn">from</span> <span class="n">google</span> <span class="kn">import</span> <span class="n">genai</span>
 
<span class="c1"># Configure o "client" (certifique-se que a  GEMINI_API_KEY está configurada no seu ambiente)
</span><span class="n">client</span> <span class="o">=</span> <span class="n">genai</span><span class="p">.</span><span class="nc">Client</span><span class="p">(</span><span class="n">api_key</span><span class="o">=</span><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="sh">"</span><span class="s">GEMINI_API_KEY</span><span class="sh">"</span><span class="p">])</span>
 
<span class="c1"># --- Passo 1: Resuma o texto ---
</span><span class="n">original_text</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Large language models are powerful AI systems trained on vast amounts of text data. They can generate human-like text, translate languages, write different kinds of creative content, and answer your questions in an informative way.</span><span class="sh">"</span>
<span class="n">prompt1</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Resuma o seguinte texto em uma setença: </span><span class="si">{</span><span class="n">original_text</span><span class="si">}</span><span class="sh">"</span>
 
<span class="c1"># Use "client.models.generate_content"
</span><span class="n">response1</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="nf">generate_content</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="sh">'</span><span class="s">gemini-2.0-flash</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">contents</span><span class="o">=</span><span class="n">prompt1</span>
<span class="p">)</span>
<span class="n">summary</span> <span class="o">=</span> <span class="n">response1</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="nf">strip</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Resumo: </span><span class="si">{</span><span class="n">summary</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
 
<span class="c1"># --- Passo 2: Traduza o sumário---
</span><span class="n">prompt2</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Traduza o seginte texto em Português, retorne apenas a tradução, sem texto adicional: </span><span class="si">{</span><span class="n">summary</span><span class="si">}</span><span class="sh">"</span>
 
<span class="c1"># Use "client.models.generate_content"
</span><span class="n">response2</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="nf">generate_content</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="sh">'</span><span class="s">gemini-2.0-flash</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">contents</span><span class="o">=</span><span class="n">prompt2</span>
<span class="p">)</span>
<span class="n">translation</span> <span class="o">=</span> <span class="n">response2</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="nf">strip</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Tradução: </span><span class="si">{</span><span class="n">translation</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="workflow-roteamento-ou-handoff"><em>Workflow</em>: Roteamento ou Handoff</h3>

<p><img src="/assets/img/post_07_08/routing-or-handoff.png" alt="routeamento" /></p>

<p>Um <em>LLM</em> inicial atua como um roteador, classificando a entrada do usuário e direcionando-a para a tarefa especializada ou <em>LLM</em> mais apropriada. Esse padrão implementa uma separação de responsabilidades e permite otimizar tarefas individuais (usando prompts especializados, modelos diferentes ou ferramentas específicas) isoladamente. Ele melhora a eficiência e potencialmente reduz custos ao usar modelos menores para tarefas mais simples. Quando uma tarefa é roteada, o agente selecionado “assume” a responsabilidade pela conclusão.</p>

<blockquote>
  <p>O termo <em>“handoff”</em> é uma expressão americana que significa a passagem de responsabilidades de um funcionário ou departamento para outro mais qualificado.</p>
</blockquote>]]></content><author><name>Philipp Schmid</name></author><category term="Programação" /><category term="IA Generativa" /><category term="Chatbots" /><summary type="html"><![CDATA[Agentes de IA. IA Agêntica. Arquitetura Agêntica. Workflow Agênticos. Modelos Agênticos. Agentes estão em todos os lugares. Mas o que exatamente são eles, e como construir sistemas agênticos robustos e eficazes? Enquanto o termo “agente” é amplamente usado, uma característica fundamental é a sua capacidade de planejar e executar tarefas dinamicamente, frequentemente utilizando ferramentas externas e memória para alcançar objetivos complexos.]]></summary></entry></feed>