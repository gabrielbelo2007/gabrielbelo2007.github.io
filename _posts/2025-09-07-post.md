---
layout: post
image: assets/img/post_07_08/header_post_07_08.png
image_caption: Uma imagem ilustrativa do avanço dos Agentes de IA
title: "Do Zero ao Um: Aprendendo Modelos de Agente"
subtitle: Como construir sistemas agênticos robustos e eficazes?
date: 2025-07-08
author: Philipp Schmid
tradutor: Gabriel A. Belo
categories: [Matemática]
tags: [IA Generativa, Chatbots]
---

Agentes de IA. IA Agêntica. Arquitetura Agêntica. *Workflow* Agênticos. Modelos Agênticos. Agentes estão em todos os lugares. Mas o que exatamente são eles, e como construir sistemas agênticos robustos e eficazes? Enquanto o termo "agente" é amplamente usado, uma característica fundamental é a sua capacidade de planejar e executar tarefas dinamicamente, frequentemente utilizando **ferramentas externas** e **memória** para alcançar objetivos complexos.

Este post tem como objetivo explorar modelos de design comuns. Visualizar essas estruturas como padrões reutilizáveis para construir aplicações de IA. Compreendê-los oferece um modelo mental para solucionar problemas complexos e projetar sistemas que sejam escaláveis, modulares e adaptáveis.

Vamos aprofundar em diversos padrões comuns diferenciando entre *workflows* mais estruturados e padrões agênticos mais dinâmicos. *Workflows* geralmente seguem caminhos predefinidos, enquanto agentes possuem mais autonomia para decidir seu curso de ação.

### Por que "Padrões Agênticos" importam?

- Padrões oferecem uma maneira estruturada de pensar e projetar sistemas.

- Padrões nos permitem construir e expandir aplicações de IA em complexidade e adaptar a requisitos variáveis. Designs modulares baseados em padrões são mais fáceis de modificar e estender.

- Padrões ajudam a gerenciar a complexidade da coordenação de múltiplos agentes, ferramentas e fluxos de trabalho, oferecendo modelos reutilizáveis e confiáveis. Eles promovem as melhores práticas e o entendimento compartilhado entre os desenvolvedores.

### Quando (e quando não) usar Agentes?

Antes de mergulharmos nos padrões, é crucial considerar quando uma abordagem agêntica é realmente necessária.

- Sempre busque a solução mais simples primeiro. Se você souber os passos exatos necessários para resolver um problema, um fluxo de trabalho fixo ou até mesmo um script simples pode ser mais eficiente e acertivo do que um agente.

- Sistemas agênticos frequentemente trocam o aumento da latência e do custo computacional por um desempenho potencialmente melhor em tarefas complexas, ambíguas ou dinâmicas. Certifique-se de que os benefícios superam esses custos.

- Use *workflows* para previsibilidade e consistência ao lidar com tarefas bem definidas onde os passos são conhecidos.

- Use agentes quando flexibilidade, adaptabilidade e tomadas de decisões orientadas por modelos são necessárias.

- Mantenha a Simplicidade (ainda que com agentes): Mesmo ao construir sistemas agênticos, esforce-se pelo design mais simples e eficaz. Agentes excessivamente complexos podem se tornar difíceis de depurar e gerenciar.

- Agentes introduzem imprevisibilidade inerente e potenciais erros. Sistemas agênticos devem incorporar registro de erros robusto, tratamento de exceções e mecanismos de repetição, dando ao sistema (ou ao LLM subjacente) a chance de se autocorrigir.

Abaixo, exploraremos 3 padrões de *workflows* comuns e 4 padrões agênticos. Ilustraremos cada um usando chamadas de API puras, sem depender de frameworks específicos como LangChain, LangGraph, LlamaIndex ou CrewAI, para focar nos conceitos centrais.

### Visão Geral dos Padrões

Vamos cobrir os seguintes modelos:

- [*Workflow*: Prompt encadeado](#workflow-prompt-encadeado)
- [*Workflow*: Roteamento ou *Handoff*](#workflow-roteamento-ou-handoff)
- [*Workflow*: Paralelização](#workflow-paralelização)
- [Padrão de Reflexão](#padrão-de-reflexão)
- [Padrão de Uso de Ferramentas](#padrão-de-uso-de-ferramentas)
- [Padrão: Planejamento (Orquestrador-Trabalhadores)](#padrão-planejamento-orquestrador-trabalhadores)
- [Padrão: Multiagente](#padrão-multiagente)

### *Workflow*: Prompt encadeado

![prompt-encadeado]({{ site.baseurl }}/assets/img/post_07_08/prompt-chaining.png)

A saída de uma chamada de *LLM* alimenta sequencialmente a entrada da próxima chamada de *LLM*. Esse padrão decompõe uma tarefa em uma sequência fixa de passos. Cada passo é tratado por uma chamada de *LLM* que processa a saída da anterior. É adequado para tarefas que podem ser divididas de forma clara em subtarefas previsíveis e sequenciais.

#### Casos de Uso

- **Gerar um documento estruturado**: *LLM 1* cria um esboço, *LLM 2* valida o esboço contra critérios, *LLM 3* escreve o conteúdo com base no esboço validado.

- **Processamento de dados em várias etapas**: Extrair informações, transformá-las e depois resumi-las.

- **Gerar conjunto de notícias com base em entradas curadas**.

```python

import os
from google import genai
 
# Configure o "client" (certifique-se que a  GEMINI_API_KEY está configurada no seu ambiente)
client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])
 
# --- Passo 1: Resuma o texto ---
original_text = "Large language models are powerful AI systems trained on vast amounts of text data. They can generate human-like text, translate languages, write different kinds of creative content, and answer your questions in an informative way."
prompt1 = f"Resuma o seguinte texto em uma setença: {original_text}"
 
# Use "client.models.generate_content"
response1 = client.models.generate_content(
    model='gemini-2.0-flash',
    contents=prompt1
)
summary = response1.text.strip()
print(f"Resumo: {summary}")
 
# --- Passo 2: Traduza o sumário---
prompt2 = f"Traduza o seginte texto em Português, retorne apenas a tradução, sem texto adicional: {summary}"
 
# Use "client.models.generate_content"
response2 = client.models.generate_content(
    model='gemini-2.0-flash',
    contents=prompt2
)
translation = response2.text.strip()
print(f"Tradução: {translation}")

```

### *Workflow*: Roteamento ou Handoff

![routeamento]({{ site.baseurl }}/assets/img/post_07_08/routing-or-handoff.png)

Um *LLM* inicial atua como um roteador, classificando a entrada do usuário e direcionando-a para a tarefa especializada ou *LLM* mais apropriada. Esse padrão implementa uma separação de responsabilidades e permite otimizar tarefas individuais (usando prompts especializados, modelos diferentes ou ferramentas específicas) isoladamente. Ele melhora a eficiência e potencialmente reduz custos ao usar modelos menores para tarefas mais simples. Quando uma tarefa é roteada, o agente selecionado "assume" a responsabilidade pela conclusão.

> O termo *"handoff"* é uma expressão americana que significa a passagem de responsabilidades de um funcionário ou departamento para outro mais qualificado.